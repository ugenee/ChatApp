"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../fetch/dist/index.js
var require_dist = __commonJS({
  "../fetch/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports2 = {};
    __export2(index_exports2, {
      builder: () => builder2,
      default: () => index_default2,
      fetchResponseTypeName: () => fetchResponseTypeName,
      generateClient: () => generateClient2,
      generateFetchHeader: () => generateFetchHeader2,
      generateRequestFunction: () => generateRequestFunction
    });
    module2.exports = __toCommonJS2(index_exports2);
    var import_core2 = require("@orval/core");
    var import_core22 = require("@orval/core");
    var generateRequestFunction = ({
      queryParams,
      headers,
      operationName,
      response,
      mutator,
      body,
      props,
      verb,
      formData,
      formUrlEncoded,
      override
    }, { route, context, pathRoute }) => {
      var _a, _b, _c;
      const isRequestOptions = (override == null ? void 0 : override.requestOptions) !== false;
      const isFormData = (override == null ? void 0 : override.formData.disabled) === false;
      const isFormUrlEncoded = (override == null ? void 0 : override.formUrlEncoded) !== false;
      const getUrlFnName = (0, import_core22.camel)(`get-${operationName}-url`);
      const getUrlFnProps = (0, import_core22.toObjectString)(
        props.filter(
          (prop) => prop.type === import_core22.GetterPropType.PARAM || prop.type === import_core22.GetterPropType.NAMED_PATH_PARAMS || prop.type === import_core22.GetterPropType.QUERY_PARAM
        ),
        "implementation"
      );
      const spec = context.specs[context.specKey].paths[pathRoute];
      const parameters = ((_a = spec == null ? void 0 : spec[verb]) == null ? void 0 : _a.parameters) || [];
      const explodeParameters = parameters.filter((parameter) => {
        const { schema } = (0, import_core22.resolveRef)(parameter, context);
        return schema.in === "query" && schema.explode;
      });
      const explodeParametersNames = explodeParameters.map((parameter) => {
        const { schema } = (0, import_core22.resolveRef)(parameter, context);
        return schema.name;
      });
      const explodeArrayImplementation = explodeParameters.length > 0 ? `const explodeParameters = ${JSON.stringify(explodeParametersNames)};

    if (value instanceof Array && explodeParameters.includes(key)) {
      value.forEach((v) => normalizedParams.append(key, v === null ? 'null' : v.toString()));
      return;
    }
      ` : "";
      const isExplodeParametersOnly = explodeParameters.length === parameters.length;
      const nomalParamsImplementation = `if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }`;
      const getUrlFnImplementation = `export const ${getUrlFnName} = (${getUrlFnProps}) => {
${queryParams ? `  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    ${explodeArrayImplementation}
    ${!isExplodeParametersOnly ? nomalParamsImplementation : ""}
  });` : ""}

  ${queryParams ? `const stringifiedParams = normalizedParams.toString();` : ``}

  ${queryParams ? `return stringifiedParams.length > 0 ? \`${route}${"?${stringifiedParams}"}\` : \`${route}\`` : `return \`${route}\``}
}
`;
      const isContentTypeNdJson = (contentType) => contentType === "application/nd-json" || contentType === "application/x-ndjson";
      const isNdJson = response.contentTypes.some(isContentTypeNdJson);
      const responseTypeName = fetchResponseTypeName(
        override.fetch.includeHttpResponseReturnType,
        isNdJson ? "Response" : response.definition.success,
        operationName
      );
      const allResponses = [...response.types.success, ...response.types.errors];
      if (allResponses.length === 0) {
        allResponses.push({
          contentType: "",
          hasReadonlyProps: false,
          imports: [],
          isEnum: false,
          isRef: false,
          key: "default",
          schemas: [],
          type: "unknown",
          value: "unknown"
        });
      }
      const nonDefaultStatuses = allResponses.filter((r) => r.key !== "default").map((r) => r.key);
      const responseDataTypes = allResponses.map(
        (r) => `export type ${responseTypeName}${(0, import_core2.pascal)(r.key)} = {
  ${isContentTypeNdJson(r.contentType) ? "stream: Response" : `data: ${r.value || "unknown"}`}
  status: ${r.key === "default" ? nonDefaultStatuses.length ? `Exclude<HTTPStatusCodes, ${nonDefaultStatuses.join(" | ")}>` : "number" : r.key}
}`
      ).join("\n\n");
      const compositeName = `${responseTypeName}Composite`;
      const compositeResponse = `${compositeName} = ${allResponses.map((r) => `${responseTypeName}${(0, import_core2.pascal)(r.key)}`).join(" | ")}`;
      const responseTypeImplementation = override.fetch.includeHttpResponseReturnType ? `${responseDataTypes}
    
export type ${compositeResponse};
    
export type ${responseTypeName} = ${compositeName} & {
  headers: Headers;
}

` : "";
      const getUrlFnProperties = props.filter(
        (prop) => prop.type === import_core22.GetterPropType.PARAM || prop.type === import_core22.GetterPropType.QUERY_PARAM || prop.type === import_core22.GetterPropType.NAMED_PATH_PARAMS
      ).map((param) => {
        if (param.type === import_core22.GetterPropType.NAMED_PATH_PARAMS) {
          return param.destructured;
        } else {
          return param.name;
        }
      }).join(",");
      const args = `${(0, import_core22.toObjectString)(props, "implementation")} ${isRequestOptions ? `options?: RequestInit` : ""}`;
      const returnType = `Promise<${responseTypeName}>`;
      const globalFetchOptions = (0, import_core22.isObject)(override == null ? void 0 : override.requestOptions) ? `${(_c = (_b = (0, import_core22.stringify)(override == null ? void 0 : override.requestOptions)) == null ? void 0 : _b.slice(1, -1)) == null ? void 0 : _c.trim()}` : "";
      const fetchMethodOption = `method: '${verb.toUpperCase()}'`;
      const ignoreContentTypes = ["multipart/form-data"];
      const fetchHeadersOption = body.contentType && !ignoreContentTypes.includes(body.contentType) ? `headers: { 'Content-Type': '${body.contentType}',${headers ? "...headers," : ""} ...options?.headers }` : headers ? "headers: {...headers, ...options?.headers}" : "";
      const requestBodyParams = (0, import_core22.generateBodyOptions)(
        body,
        isFormData,
        isFormUrlEncoded
      );
      const fetchBodyOption = requestBodyParams ? isFormData && body.formData || isFormUrlEncoded && body.formUrlEncoded ? `body: ${requestBodyParams}` : `body: JSON.stringify(${requestBodyParams})` : "";
      const fetchFnOptions = `${getUrlFnName}(${getUrlFnProperties}),
  {${globalFetchOptions ? "\n" : ""}      ${globalFetchOptions}
    ${isRequestOptions ? "...options," : ""}
    ${fetchMethodOption}${fetchHeadersOption ? "," : ""}
    ${fetchHeadersOption}${fetchBodyOption ? "," : ""}
    ${fetchBodyOption}
  }
`;
      const fetchResponseImplementation = isNdJson ? `const stream = await fetch(${fetchFnOptions})

  ${override.fetch.includeHttpResponseReturnType ? "return { status: stream.status, stream, headers: stream.headers }" : `return stream`}
  ` : `const res = await fetch(${fetchFnOptions})

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: ${responseTypeName}${override.fetch.includeHttpResponseReturnType ? `['data']` : ""} = body ? JSON.parse(body) : {}

  ${override.fetch.includeHttpResponseReturnType ? `return { data, status: res.status, headers: res.headers } as ${responseTypeName}` : "return data"}
`;
      const customFetchResponseImplementation = `return ${mutator == null ? void 0 : mutator.name}<${responseTypeName}>(${fetchFnOptions});`;
      const bodyForm = (0, import_core22.generateFormDataAndUrlEncodedFunction)({
        formData,
        formUrlEncoded,
        body,
        isFormData,
        isFormUrlEncoded
      });
      const fetchImplementationBody = mutator ? customFetchResponseImplementation : fetchResponseImplementation;
      const fetchImplementation = `export const ${operationName} = async (${args}): ${returnType} => {
  ${bodyForm ? `  ${bodyForm}` : ""}
  ${fetchImplementationBody}}
`;
      const implementation = `${responseTypeImplementation}${getUrlFnImplementation}
${fetchImplementation}
`;
      return implementation;
    };
    var fetchResponseTypeName = (includeHttpResponseReturnType, definitionSuccessResponse, operationName) => {
      return includeHttpResponseReturnType ? `${operationName}Response` : definitionSuccessResponse;
    };
    var generateClient2 = (verbOptions, options) => {
      const imports = (0, import_core22.generateVerbImports)(verbOptions);
      const functionImplementation = generateRequestFunction(verbOptions, options);
      return {
        implementation: `${functionImplementation}
`,
        imports
      };
    };
    var getHTTPStatusCodes = () => `
export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes = HTTPStatusCode1xx | HTTPStatusCode2xx | HTTPStatusCode3xx | HTTPStatusCode4xx | HTTPStatusCode5xx;

`;
    var generateFetchHeader2 = ({
      clientImplementation
    }) => {
      return clientImplementation.includes("<HTTPStatusCodes,") ? getHTTPStatusCodes() : "";
    };
    var fetchClientBuilder = {
      client: generateClient2,
      header: generateFetchHeader2,
      dependencies: () => []
    };
    var builder2 = () => () => fetchClientBuilder;
    var index_default2 = builder2;
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  builder: () => builder,
  default: () => index_default,
  generateExtraFiles: () => generateExtraFiles,
  generateMcp: () => generateMcp,
  generateServer: () => generateServer,
  getMcpHeader: () => getMcpHeader
});
module.exports = __toCommonJS(index_exports);
var import_core = require("@orval/core");
var import_zod = require("@orval/zod");
var import_fetch = __toESM(require_dist());
var getHeader = (option, info) => {
  if (!option) {
    return "";
  }
  const header = option(info);
  return Array.isArray(header) ? (0, import_core.jsDoc)({ description: header }) : header;
};
var getMcpHeader = ({
  verbOptions,
  output,
  clientImplementation
}) => {
  const targetInfo = (0, import_core.getFileInfo)(output.target);
  const schemaInfo = (0, import_core.getFileInfo)(output.schemas);
  const relativeSchemaImportPath = output.schemas ? import_core.upath.relativeSafe(targetInfo.dirname, schemaInfo.dirname) : "./" + targetInfo.filename + ".schemas";
  const importSchemaNames = Object.values(verbOptions).flatMap((verbOption) => {
    const imports = [];
    const pascalOperationName = (0, import_core.pascal)(verbOption.operationName);
    if (verbOption.queryParams) {
      imports.push(`${pascalOperationName}Params`);
    }
    if (verbOption.body.definition) {
      imports.push(`${pascalOperationName}Body`);
    }
    return imports;
  }).reduce((acc, name) => {
    if (!acc.find((i) => i === name)) {
      acc.push(name);
    }
    return acc;
  }, []);
  const importSchemasImplementation = `import {
  ${importSchemaNames.join(
    ",\n  "
  )}
} from '${relativeSchemaImportPath}';
`;
  const relativeFetchClientPath = "./http-client";
  const importFetchClientNames = Object.values(verbOptions).flatMap((verbOption) => verbOption.operationName).reduce((acc, name) => {
    if (!acc.find((i) => i === name)) {
      acc.push(name);
    }
    return acc;
  }, []);
  const importFetchClientImplementation = `import {
  ${importFetchClientNames.join(
    ",\n  "
  )}
} from '${relativeFetchClientPath}';
  `;
  const content = [
    importSchemasImplementation,
    importFetchClientImplementation
  ].join("\n");
  return content + "\n";
};
var generateMcp = async (verbOptions, options) => {
  const handlerArgsTypes = [];
  const pathParamsType = verbOptions.params.map((param) => {
    const paramName = param.name.split(": ")[0];
    const paramType = param.implementation.split(": ")[1];
    return `    ${paramName}: ${paramType}`;
  }).join(",\n");
  if (pathParamsType) {
    handlerArgsTypes.push(`  pathParams: {
${pathParamsType}
  };`);
  }
  if (verbOptions.queryParams) {
    handlerArgsTypes.push(
      `  queryParams: ${verbOptions.queryParams.schema.name};`
    );
  }
  if (verbOptions.body.definition) {
    handlerArgsTypes.push(`  bodyParams: ${verbOptions.body.definition};`);
  }
  const handlerArgsName = `${verbOptions.operationName}Args`;
  const handlerArgsImplementation = handlerArgsTypes.length ? `
export type ${handlerArgsName} = {
${handlerArgsTypes.join("\n")}
}
` : "";
  const fetchParams = [];
  if (verbOptions.params.length) {
    const pathParamsArgs = verbOptions.params.map((param) => {
      const paramName = param.name.split(": ")[0];
      return `args.pathParams.${paramName}`;
    }).join(", ");
    fetchParams.push(`${pathParamsArgs}`);
  }
  if (verbOptions.body.definition) fetchParams.push(`args.bodyParams`);
  if (verbOptions.queryParams) fetchParams.push(`args.queryParams`);
  const handlerName = `${verbOptions.operationName}Handler`;
  const handlerImplementation = `
export const ${handlerName} = async (${handlerArgsTypes.length ? `args: ${handlerArgsName}` : ""}) => {
  const res = await ${verbOptions.operationName}(${fetchParams.join(", ")});

  return {
    content: [
      {
        type: 'text' as const,
        text: JSON.stringify(res),
      },
    ],
  };
};`;
  const handlersImplementation = [
    handlerArgsImplementation,
    handlerImplementation
  ].join("");
  return {
    implementation: handlersImplementation ? `${handlersImplementation}
` : "",
    imports: []
  };
};
var generateServer = async (verbOptions, output, context) => {
  const info = context.specs[context.specKey].info;
  const { extension, dirname } = (0, import_core.getFileInfo)(output.target);
  const serverPath = import_core.upath.join(dirname, `server${extension}`);
  const header = getHeader(output.override.header, info);
  const toolImplementations = Object.values(verbOptions).map((verbOption) => {
    const imputSchemaTypes = [];
    if (verbOption.params.length)
      imputSchemaTypes.push(
        `  pathParams: ${verbOption.operationName}Params`
      );
    if (verbOption.queryParams)
      imputSchemaTypes.push(
        `  queryParams: ${verbOption.operationName}QueryParams`
      );
    if (verbOption.body.definition)
      imputSchemaTypes.push(`  bodyParams: ${verbOption.operationName}Body`);
    const imputSchemaImplementation = imputSchemaTypes.length ? `  {
  ${imputSchemaTypes.join(",\n  ")}
  },` : "";
    const toolImplementation = `
server.tool(
  '${verbOption.operationName}',
  '${verbOption.summary}',${imputSchemaImplementation ? `
${imputSchemaImplementation}` : ""}
  ${verbOption.operationName}Handler
);`;
    return toolImplementation;
  }).join("\n");
  const importToolSchemas = Object.values(verbOptions).flatMap((verbOption) => {
    const imports = [];
    if (verbOption.headers)
      imports.push(`  ${verbOption.operationName}Header`);
    if (verbOption.params.length)
      imports.push(`  ${verbOption.operationName}Params`);
    if (verbOption.queryParams)
      imports.push(`  ${verbOption.operationName}QueryParams`);
    if (verbOption.body.definition)
      imports.push(`  ${verbOption.operationName}Body`);
    return imports;
  }).join(",\n");
  const importToolSchemasImplementation = `import {
${importToolSchemas}
} from './tool-schemas.zod';`;
  const importHandlers = Object.values(verbOptions).filter(
    (verbOption) => toolImplementations.includes(`${verbOption.operationName}Handler`)
  ).map((verbOption) => `  ${verbOption.operationName}Handler`).join(`,
`);
  const importHandlersImplementation = `import {
${importHandlers}
} from './handlers';`;
  const importDependenciesImplementation = `import {
  McpServer
} from '@modelcontextprotocol/sdk/server/mcp.js';
  
import {
  StdioServerTransport
} from '@modelcontextprotocol/sdk/server/stdio.js';  
`;
  const newMcpServerImplementation = `
const server = new McpServer({
  name: '${(0, import_core.camel)(info.title)}Server',
  version: '1.0.0',
});
`;
  const serverConnectImplementation = `
const transport = new StdioServerTransport();

server.connect(transport).then(() => {
  console.error('MCP server running on stdio');
}).catch(console.error);
`;
  const content = [
    header,
    importDependenciesImplementation,
    importHandlersImplementation,
    importToolSchemasImplementation,
    newMcpServerImplementation,
    toolImplementations,
    serverConnectImplementation
  ].join("\n");
  return [
    {
      content,
      path: serverPath
    }
  ];
};
var generateZodFiles = async (verbOptions, output, context) => {
  const { extension, dirname, filename } = (0, import_core.getFileInfo)(output.target);
  const header = getHeader(
    output.override.header,
    context.specs[context.specKey].info
  );
  const zods = await Promise.all(
    Object.values(verbOptions).map(
      (verbOption) => (0, import_zod.generateZod)(
        verbOption,
        {
          route: verbOption.route,
          pathRoute: verbOption.pathRoute,
          override: output.override,
          context,
          mock: output.mock,
          output: output.target
        },
        output.client
      )
    )
  );
  const allMutators = zods.reduce(
    (acc, z) => {
      var _a;
      ((_a = z.mutators) != null ? _a : []).forEach((mutator) => {
        acc[mutator.name] = mutator;
      });
      return acc;
    },
    {}
  );
  const mutatorsImports = (0, import_core.generateMutatorImports)({
    mutators: Object.values(allMutators)
  });
  let content = `${header}import { z as zod } from 'zod';
${mutatorsImports}
`;
  const zodPath = import_core.upath.join(dirname, `tool-schemas.zod${extension}`);
  content += zods.map((zod) => zod.implementation).join("\n");
  return [
    {
      content,
      path: zodPath
    }
  ];
};
var generateHttpClinetFiles = async (verbOptions, output, context) => {
  const { extension, dirname, filename } = (0, import_core.getFileInfo)(output.target);
  const header = getHeader(
    output.override.header,
    context.specs[context.specKey].info
  );
  const clients = await Promise.all(
    Object.values(verbOptions).map((verbOption) => {
      const fullRoute = (0, import_core.getFullRoute)(
        verbOption.route,
        context.specs[context.specKey].servers,
        output.baseUrl
      );
      const options = {
        route: fullRoute,
        pathRoute: verbOption.pathRoute,
        override: output.override,
        context,
        mock: output.mock,
        output: output.target
      };
      return (0, import_fetch.generateClient)(verbOption, options, output.client, output);
    })
  );
  const clientImplementation = clients.map((client) => client.implementation).join("\n");
  const relativeSchemasPath = output.schemas ? import_core.upath.relativeSafe(dirname, (0, import_core.getFileInfo)(output.schemas).dirname) : "./" + filename + ".schemas";
  const importNames = clients.flatMap((client) => client.imports).reduce((acc, imp) => {
    if (!acc.find((i) => i === imp.name)) {
      acc.push(imp.name);
    }
    return acc;
  }, []);
  const importImplementation = `import { ${importNames.join(
    ",\n"
  )} } from '${relativeSchemasPath}';`;
  const fetchHeader = (0, import_fetch.generateFetchHeader)({
    title: "",
    isRequestOptions: false,
    isMutator: false,
    noFunction: false,
    isGlobalMutator: false,
    provideIn: false,
    hasAwaitedType: false,
    output,
    verbOptions,
    clientImplementation
  });
  const content = [
    header,
    importImplementation,
    fetchHeader,
    clientImplementation
  ].join("\n");
  const outputPath = import_core.upath.join(dirname, `http-client${extension}`);
  return [
    {
      content,
      path: outputPath
    }
  ];
};
var generateExtraFiles = async (verbOptions, output, context) => {
  const [server, zods, httpClients] = await Promise.all([
    generateServer(verbOptions, output, context),
    generateZodFiles(verbOptions, output, context),
    generateHttpClinetFiles(verbOptions, output, context)
  ]);
  return [...server, ...zods, ...httpClients];
};
var mcpClientBuilder = {
  client: generateMcp,
  header: getMcpHeader,
  extraFiles: generateExtraFiles
};
var builder = () => () => mcpClientBuilder;
var index_default = builder;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  builder,
  generateExtraFiles,
  generateMcp,
  generateServer,
  getMcpHeader
});
//# sourceMappingURL=index.js.map